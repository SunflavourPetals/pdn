# PDN 参考

## 概要

PDN（全称 Petals' Data Notation）是 SunflavourPetals（github 用户名）设计的基于 Unicode 的数据交换格式。  

PDN 的特点是：  

1. 尽可能靠近 C++ 字面量的格式；  
2. 可以对数据的类型进行一定程度的控制，并提供检查；  
3. 提供灵活的标识符格式。  

可以的情况下使用拓展名 `.spdn`。  

## 正文

### 注释

PDN 解析器将忽略注释内容，注释是为了阅读 PDN 文件的人准备的。  
在特定情况下，注释是有用的，比如使用 PDN 作为程序的一部分配置文件时。  
注释的形式有三种：  

1. 行注释：标记 `//` 至当前行的行尾或文件尾的内容是注释文本；  
2. 块注释：标记 `/*` 至标记 `*/` 的内容是块注释文本；  
3. 可嵌套块注释：标记 `</` 至标记 `/>` 的内容是可嵌套块注释文本，`/>` 只能关闭它前面距离最近的那一层可嵌套块注释。  

```pdn
// 这是行注释
/*
    这是块注释
*/
</
    这是可嵌套块注释(第一层) </ 第二层 /> 第一层
    第一层 </ 第二层 </ 第三层 /> 第二层 /> 第一层
/>
```

建议：块注释和可嵌套块注释具有一定危险性，尤其是后者，请谨慎使用。  

### 数据类型

PDN 的数据有如下 15 种类型：  

1. i8
2. i16
3. i32
4. i64
5. u8
6. u16
7. u32
8. u64
9. f32
10. f64
11. boolean
12. character
13. string
14. list
15. object

list 是列表，其元素类型不限；  
object 为对象(标识符-数据的映射结构)，其直接成员数据不能同名。  

其他标识类型的名字只能是如上类型的别名。  
标准规定了如下别名：  

1. int, i 见下文  
2. uint, u 见下文  
3. float, f 为 f32 的别名  
4. double 为 f64 的别名  
5. bool 为 boolean 的别名  
6. char, c 为 character 的别名  
7. str, s 为 string 的别名
8. obj 为 object 的别名

对于别名 int:  
`a` 属于 `{ i8, i16, i32, i64 }` 映射到 C++ 中类型的集合(通常为 `std::{ int8_t, int16_t, int32_t, int64_t}`)，如果 pdn 解析库的 C++ 环境中 `a` 是 C++ 中 `int` 类型的别名，那么 pdn 的 `int` 是 `a` 对应的 pdn 类型的别名，否则 `int` 是 `i32` 的别名。  
i 为 int 所指代类型的别名。  

对于别名 uint:  
`b` 属于 `{ u8, u16, u32, u64 }` 映射到 C++ 中类型的集合(通常为 `std::{ uint8_t, uint16_t, uint32_t, uint64_t}`)，如果 pdn 解析库的 C++ 环境中 `b` 是 C++ 中 `unsigned int` 类型的别名，那么 `uint` 是 `b` 对应的 pdn 类型的别名，否则 `uint` 是 `u32` 的别名。  
u 为 uint 所指代类型的别名。  

PDN 文件解析的结果即是一个 `Object` 类型的数据。  

### 数据定义语法

数据定义语法：  

1. `<标识符-数据名称> <表达式>`  
2. `<标识符-数据名称> : <表达式>`  
3. `<标识符-数据名称> : <标识符-类型名称> <表达式>`  

每条数据定义前或后，都可前置或尾随任意数量个分号 `;` 作为间隔符。  

第三条，解析完表达式后，将它的值转换为目标类型，如果发生溢出错误或无法进行转换，则该名称指代的数据损坏，将报告错误。  

示例：  

```pdn
// 1. <标识符-数据名称> <表达式>
iden_1 1  iden_2 2  iden_3 3
iden_4 4; iden_5 5; iden_6 6;

// 2. <标识符-数据名称> : <表达式>
iden_7:7  iden_8:8  iden_9:9
iden_a:1; iden_b:2; iden_c:3;

// 3. <标识符-数据名称> : <标识符-类型名称> <表达式>
iden_d:int 4  iden_e:int 5  iden_f:int 6
iden_g:int 7; iden_h:int 8; iden_i:int 9;

// list 和 object, 详见后文
list [1, +2, -3, ++4, +-+-5, f32:0xff, ["abc", "mn", string:"xyz"] ]
object { data_1 0 }
```

### 类型转换规则

1. `i8`、`i16`、`i32`、`i64`、`u8`、`u16`、`u32`、`u64` 在不发生溢出的情况下可以相互转换(溢出被视为错误)、可以转换为 `f32`、`f64`、`boolean`；  
2. `f32`、`f64` 可以相互转换、可以转换为 `boolean`；  
3. `boolean` 可以转换为 `i8`、`i16`、`i32`、`i64`、`u8`、`u16`、`u32`、`u64`、`f32`、`f64`，其中 `false` 将被转换为 `0`，`true` 将被转换为 `1`，从其他类型转换到 `boolean` 时，非零值被转换为 `true`，零被转换为 `false`。  

只有在整数类型之间相互转换时可能发生溢出错误，其余转换不会发生错误。

这意味着转换后与转换前的值不一定相等。  
如将一个很大的整数转化为 `float` 值，那么它可能被转化成了一个近似值。  

### 运算符

对整数和浮点数有一元运算符 `+`，对于 `+N`，运算的结果为 `N`，运算结果的类型和 `N` 的类型相同；  
对有符号整数和浮点数有 一元运算符 `-`，对于 `-N`，运算的结果为数学意义上的 `-N`，运算结果的类型和 `N` 的类型相同。  

示例：  

```pdn
+1 等价于 1
-1 等价于 -1
++1 等价于 1
--1 等价于 1
+-1 等价于 -1
-+1 等价于 -1
---1 等价于 -1
...
```

### 表达式

带零至多个正号与负号的[字面量](#字面量)、[List 表达式](#list-表达式)、[object 表达式](#object-表达式)被称为表达式。  

示例：  

```pdn
123
+456
-789
+-+-1
[] // list 表达式
[ 1, 2, 3 ] // list 表达式
{} // object 表达式
{ a 1; b 2; c 3 } // object 表达式
```

#### List 表达式

List 表达式语法：  

`[ <元素序列> ]`  

`<元素序列>` 为零至多个元素定义，两个相邻元素必须由一个逗号 `,` 隔开，末尾元素可尾随一个逗号(可选)。  

##### List 元素定义

List 元素定义语法：  

1. `<表达式>`  
2. `<标识符-类型名称> : <表达式>`  

第二条的标识符用于转换表达式的类型。  

示例：  

```pdn
list [ 1, 2, 3, f32:0xff, [ "abc", "mn", string:"xyz" ] ]
```

#### Object 表达式

Object 表达式语法：  

`{ <成员数据序列> }`  

`<成员数据序列>` 即零至多条[数据定义](#数据定义语法)。  

示例：  

```pdn
object { data1:f64 123; data2:f32 456; data3:789; my_list [ 1, 2, 3 ] }
```

### 标识符

标识符可以作为数据或类型的名称，形式有三种：  

1. 普通标识符；  
2. 字符串标识符；  
3. 原始字符串标识符。  

#### 普通标识符

普通标识符的词法为 `首字符` 后紧跟任意个 `其他字符` 或 `首字符` 中的字符。  

`首字符` 可以为下列字符之一：  

```text
_ a b c d e f g h i j k l m
  n o p q r s t u v w x y z
  A B C D E F G H I J K L M
  N O P Q R S T U V W X Y Z
```

和以下 Unicode 码位对应的字符：  
00A8、00AA、00AD、00AF、00B2-00B5、00B7-00BA、00BC-00BE、00C0-00D6、00D8-00F6、00F8-00FF、0100-02FF、0370-167F、1681-180D、180F-1DBF、1E00-1FFF、200B-200D、202A-202E、203F-2040、2054、2060-206F、2070-20CF、2100-218F、2460-24FF、2776-2793、2C00-2DFF、2E80-2FFF、3004-3007、3021-302F、3031-303F、3040-D7FF、F900-FD3D、FD40-FDCF、FDF0-FE1F、FE30-FE44、FE47-FFFD、10000-1FFFD、20000-2FFFD、30000-3FFFD、40000-4FFFD、50000-5FFFD、60000-6FFFD、70000-7FFFD、80000-8FFFD、90000-9FFFD、A0000-AFFFD、B0000-BFFFD、C0000-CFFFD、D0000-DFFFD、E0000-EFFFD

`其他字符` 为下列字符：  

```text
  0 1 2 3 4 5 6 7 8 9
```

和以下 Unicode 码位对应的字符：  
0300-036F、1DC0-1DFF、20D0-20FF、FE20-FE2F  

标识符示例：  

```pdn
identifier
标识符
識別子
iden1234_1234
名字0
_1
```

出于某些原因，标识符不支持通用字符名：  

```C++
int \u3042 = 100; // 在 C++ 中使用通用字符名表示平假名 あ
```

```spdn
// \u3042: 100 // 不可以
test1 { あ: 100 } // OK
test2 { `\u3042`: 100 } // OK 使用字符串标识符
// test1 和 test2 都有成员 あ
```

PDN 对标识符的定义参考了 MSVC 的 C++ 标识符文档(不含 `MSVC 专用` 部分)。  
[参考 MSDN](https://learn.microsoft.com/zh-cn/cpp/cpp/identifiers-cpp "zh-cn")  
[摘录 MSDN](#摘录-msdn-cpp-标识符)  

#### 字符串标识符

字符串标识符是由一对反引号 `` ` `` 包含的字符串形式的标识符，  
支持转义字符，不可包含换行符 LF、非转义序列的反引号 `` ` `` 和非转义序列的反斜杠 `\`。
字符串标识符示例：  

```pdn
`123456`
`this is an identifier\n`
`iden` // 等价于 iden
```

特殊案例：  

```pdn
`123
456`
// 当使用 CR 作为换行符时，它合法，等价于 `123\r456`，
// 使用 LS(U+2028) 或 PS(U+2029) 作为换行符时，它同样合法，
// 当使用 CRLF 或 LF 作为换行符时，它非法，因为字符串中含有换行符 LF。
```

#### 原始标识符字符串

原始字符串标识符是原始字符串形式的标识符，  
形式为：  

```pdn
@`d_seq(r_seq)d_seq`
```

`d_seq` 为一个或多个[基本字符集(C++26)](https://zh.cppreference.com/w/cpp/language/charset#.E5.9F.BA.E6.9C.AC.E5.AD.97.E7.AC.A6.E9.9B.86)中的字符，不包括括号、反斜杠和空白字符，最多十六个。  

`r_seq` 为一个或多个[翻译字符集](https://zh.cppreference.com/w/cpp/language/charset)中的字符，不得包含闭序列 `` )d_seq` ``。  

原始字符串的内容即为 `r_seq` 中的内容。  

原始字符串标识符示例：  

```pdn
@`(123456)` // 等价于 `123456`
@`1234abcdABCD(标识符)1234abcdABCD` // 等价于 标识符
@`(C:\Users\)` // 等价于 `C:\\Users\\`
```

特殊情况：当使用 CRLF 作为换行符时，即若 CRLF 出现在原始字符串或原始字符串标识符的内容中时，它被转换成 LF，这是由于 C++ [翻译阶段一](https://en.cppreference.com/w/cpp/language/translation_phases#Phase_1)，PDN 继承了这一行为。  

### 字面量

#### 整数字面量

PDN 的整数字面量无任何后缀，其余词法与 C++ 整数字面量一致。  
整数字面量持有的类型从以下类型中根据是否能表示该值依次选择：  
`int`、`i8`、`i16`、`i32`、`i64`、`u64`。  
`int` 由用户使用的平台/编译器根据 C++ `int` 类型的大小自动选择，  
其策略见[数据类型](#数据类型)。  

整数字面量示例：  

```pdn
// 十进制
1
123'456'789

// 二进制
0b1111'0000
0B0

// 十六进制
0xffff'0000
0x0000'FFFF
0XFf'Ee'Dd'Cc
0xaA'bB'cC'Dd

// 八进制
0
0777
01'234'567
```

[参考 C++ Reference](https://zh.cppreference.com/w/cpp/language/integer_literal)  

#### 浮点数字面量

PDN 的浮点字面量无任何后缀，其余词法与 C++ 整数字面量一致。  

浮点字面量示例：  

```pdn
0.
.0
3.14
1.25e2     // 125
1e-2       // 0.01
123'456.0
0xff'ffp-2 // 16383.75
0x1.p1     // 2
0x.8p+1     // 1
```

[参考 C++ Reference](https://zh.cppreference.com/w/cpp/language/floating_literal)  

#### 字符字面量

PDN 的字符字面量是由一对单引号 `'` 包围一个“字符”，  
其“字符”可以是翻译字符集除换行符 LF、反斜杠 `\`、单引号 `'` 以外的字符或转义字符，  
转义字符必须是一个 Unicode 标量值。  

字符字面量示例：  

```pdn
'c'
'字'
'\x{2028}' // U+2028 LS
```

[转义字符小节](#转义)  

#### 字符串字面量

##### 普通字符串

PDN 的字符串无任何前缀如 `u8`、`u`、`U`、`L`，pdn 解析器的解析结果使用哪种 utf 编码和编写 pdn 文件的用户无关。  
其余与 C++ 的非原始字符串的字符串词法相同：双引号 `"` 及其包围的内容(不含反斜线 `\`，不在转义序列的双引号 `"` 和换行符 LF)。  
字符串字面量示例：  

```pdn
"Hello, world!"
"你好，世界！"
"123\n\t456\0xyz"
```

特殊案例：  

```pdn
"123
456"
// 当使用 CR 作为换行符时，它合法，等价于 `123\r456`，
// 使用 LS(U+2028) 或 PS(U+2029) 作为换行符时，它同样合法，
// 当使用 CRLF 或 LF 作为换行符时，它非法，因为字符串中含有换行符 LF。
```

[参考 C++ Reference](https://zh.cppreference.com/w/cpp/language/string_literal)  

##### 原始字符串

PDN 的原始字符串无任何前缀如 `u8`、`u`、`U`、`L`，pdn 解析器使用哪种 utf 编码和编写 pdn 文件的用户无关。  
PDN 使用 `@` 代替了 C++ 原始字符串的前缀 `R`，其余与 C++ 的原始字符串的词法相同。  
原始字符串字面量示例：  

```pdn
@"(Hello, world!)"
@"RawStrDS(你好，世界！)RawStrDS"
@"(C:\Users\)" // 等价于 "C:\\Users\\"
```

特殊情况：当使用 CRLF 作为换行符时，即若 CRLF 出现在原始字符串或原始字符串标识符的内容中时，它被转换成 LF，这是由于 C++ [翻译阶段一](https://en.cppreference.com/w/cpp/language/translation_phases#Phase_1)，PDN 继承了这一行为。  

[参考 C++ Reference](https://zh.cppreference.com/w/cpp/language/string_literal)  

使用 `@` 代替 `R` 的原因：  
PDN 并没有强制标识符与字符串之间必须存在空白字符，即 `R"string"` 或 `R@"(raw string)"` 是合法的。如果使用 `R` 前缀，它将与标识符冲突，即如果不在词法解析时回溯，本应被解析为标识符 `R` 和字符串 `"string"` 的 `R"string"` 将被视为未命名的且词法错误的原始字符串，我不想给词法解析器太多压力，也不想让它毁了我的 PDN 使用体验(如果我可以写`A""`、`B""`...唯独不可以写`R""`，我会很失望)。  
整数/浮点字面量的分隔符 `'` 和字符字面量同样存在冲突，例如 `123'456'C'` 看起来应该应该是 `123456` 和字符 `'C'`，事实也确实如此，如果解析它，我需要在词法分析的时候回溯，这是我不希望看到的事情。于是我考虑 C# 风格的分隔符，我挺欣赏它，但是问题接踵而至，由于 PDN 也不强制字面量和标识符之间必须存在空白字符，`123_456_ABC` 将被视为合法，如果我要把它解析为 `123456` 和 `_ABC`，我还是需要回溯，最后我还是选择以 `'` 作为分隔符，我实现的词法分析器并不能正确识别 `123'C'` 为 `123` 和 `'C'`，但是即使我实现了，它也会造成语法错误，这让我多少有些心安理得，也算是为了不回溯的妥协之策。  

回溯意为着我要重写很多东西，并且重写之后这些东西会变得更大、更慢、更复杂。  

##### 拼接字符串

PDN 支持拼接字符串，普通字符串字面量和原始字符串字面量可以混合拼接。  
拼接字符串示例：  

```pdn
concatenation_str_1 "Hello" ", " "world" "!" // 等价于 "Hello, world!"
concatenation_str_2 @"(Hello, )" @"WORLD(world!)WORLD" // 等价于 "Hello, world!"
concatenation_str_3 "C:" @"(\)" "Users" @"(\)" // 等价于 @"(C:\Users\)" 或 "C:\\Users\\"
```

### 转义

PDN 支持 C++ 的转义序列(除了条件转义序列)和通用字符名。  
注：实现的 PDN 解析器不支持通用字符名的 `\N{NAME}`。  

1. 简单转义序列：如 `\a`、`\t`、`\n` 等  
2. `\n*` 其中 `n*` 为一至三位八进制数: 如 `\0`、`\101` 等  
3. `\o{n*}` 其中 `n*` 为一至多位八进制数  
4. `\xn*` 其中 `n*` 为一至多位十六进制数  
5. `\x{n*}` 其中 `n*` 为一至多位十六进制数  
6. `\unnnn` 其中 `nnnn` 为四位十六进制数  
7. `\u{n*}` 其中 `n*` 为一至多位十六进制数  
8. `\Unnnnnnnn` 其中 `nnnnnnnn` 为八位十六进制数  
9. `\N{NAME}` 以 `NAME` 命名的字符(本仓库的实现 PDN 不支持)

如果转义结果不是 Unicode 标量值则是错误。  

[参考 C++ Reference](https://zh.cppreference.com/w/cpp/language/escape)  

### At标识符

At 标识符的词法为 `@` 紧跟着[普通标识符](#普通标识符)，其值由 PDN 解析器的常量表映射函数提供，用户可自行替换以简化数据的配置或达到动态数据的效果，如获取值时返回 random 值，值的类型可以为整数、浮点数、布尔值、字符或字符串等。  

至少提供以下 At 标识符：  
（包含 C++20 起的所有非模板的数学常数）  

| At 标识符        | 类型      | 值                                          |
| :--------------: | :-------: | :-----------------------------------------: |
| `@true`          | `boolean` | `true`                                      |
| `@false`         | `boolean` | `false`                                     |
| `@e`             | `f64`     | `std::numbers::e`                           |
| `@log2e`         | `f64`     | `std::numbers::log2e`                       |
| `@log10e`        | `f64`     | `std::numbers::log10e`                      |
| `@pi`            | `f64`     | `std::numbers::pi`                          |
| `@inv_pi`        | `f64`     | `std::numbers::inv_pi`                      |
| `@inv_sqrtpi`    | `f64`     | `std::numbers::inv_sqrtpi`                  |
| `@ln2`           | `f64`     | `std::numbers::ln2`                         |
| `@ln10`          | `f64`     | `std::numbers::ln10`                        |
| `@sqrt2`         | `f64`     | `std::numbers::sqrt2`                       |
| `@sqrt3`         | `f64`     | `std::numbers::sqrt3`                       |
| `@inv_sqrt3`     | `f64`     | `std::numbers::inv_sqrt3`                   |
| `@egamma`        | `f64`     | `std::numbers::egamma`                      |
| `@phi`           | `f64`     | `std::numbers::phi`                         |
| `@infinity`      | `f64`     | `std::numeric_limits<f64>::infinity()`      |
| `@inf`           | `f64`     | 同 `@infinity`                              |
| `@quiet_NaN`     | `f64`     | `std::numeric_limits<f64>::quiet_NaN()`     |
| `@qNaN`          | `f64`     | 同 `@quiet_NaN`                             |
| `@qnan`          | `f64`     | 同 `@quiet_NaN`                             |
| `@NaN`           | `f64`     | 同 `@quiet_NaN`                             |
| `@nan`           | `f64`     | 同 `@quiet_NaN`                             |
| `@signaling_NaN` | `f64`     | `std::numeric_limits<f64>::signaling_NaN()` |
| `@sNaN`          | `f64`     | 同 `@signaling_NaN`                         |
| `@snan`          | `f64`     | 同 `@signaling_NaN`                         |

本仓库的实现额外提供了如下 At 标识符(仅供特性测试)：  

| At 标识符        | 类型      | 值                                          |
| :--------------: | :-------: | :-----------------------------------------: |
| `@π`             | `f64`     | 同 `@pi`                                    |
| `@γ`             | `f64`     | 同 `@egamma`                                |
| `@Φ`             | `f64`     | 同 `@phi`                                   |
| `@hello`         | `string`  | `"Hello, world!"`                           |
| `@fib_10_list`   | `list`    | 斐波那契数列前十项元素，类型均为整型        |
| `@me_object`     | `object`  | 省略                                        |

## 摘录

### 摘录-MSDN

#### 摘录-MSDN-CPP-标识符

允许将以下字符用作标识符的任意字符：  

```text
_ a b c d e f g h i j k l m
  n o p q r s t u v w x y z
  A B C D E F G H I J K L M
  N O P Q R S T U V W X Y Z
```

允许将以下 Unicode 码位数字范围用作标识符中的任意字符：  

00A8、00AA、00AD、00AF、00B2-00B5、00B7-00BA、00BC-00BE、00C0-00D6、00D8-00F6、00F8-00FF、0100-02FF、0370-167F、1681-180D、180F-1DBF、1E00-1FFF、200B-200D、202A-202E、203F-2040、2054、2060-206F、2070-20CF、2100-218F、2460-24FF、2776-2793、2C00-2DFF、2E80-2FFF、3004-3007、3021-302F、3031-303F、3040-D7FF、F900-FD3D、FD40-FDCF、FDF0-FE1F、FE30-FE44、FE47-FFFD、10000-1FFFD、20000-2FFFD、30000-3FFFD、40000-4FFFD、50000-5FFFD、60000-6FFFD、70000-7FFFD、80000-8FFFD、90000-9FFFD、A0000-AFFFD、B0000-BFFFD、C0000-CFFFD、D0000-DFFFD、E0000-EFFFD  

允许将以下字符用作标识符中除第一个字符以外的任意字符：  

```text
  0 1 2 3 4 5 6 7 8 9
```

还允许将以下 Unicode 码位数字范围用作标识符中除第一个字符以外的任意字符：  
0300-036F、1DC0-1DFF、20D0-20FF、FE20-FE2F  
